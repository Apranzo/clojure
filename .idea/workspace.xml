<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="47b5f02a-aa95-49a9-9129-c3d1d4dcc5fa" name="Default Changelist" comment="i">
      <change afterPath="$PROJECT_DIR$/.lein-failures" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/pom.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/task02/db.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/task02/db.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/task02/network.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/task02/network.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/task02/query.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/task02/query.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/META-INF/maven/by.clojurecourse/task02/pom.properties" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/META-INF/maven/by.clojurecourse/task02/pom.properties" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/task02/db$delete.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/task02/db$delete.class" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/task02/db$insert.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/task02/db$insert.class" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/task02/db$load_initial_data.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/task02/db$load_initial_data.class" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/task02/db$update.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/task02/db$update.class" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/task02/db__init.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/task02/db__init.class" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/stale/leiningen.core.classpath.extract-native-dependencies" beforeDir="false" afterPath="$PROJECT_DIR$/target/stale/leiningen.core.classpath.extract-native-dependencies" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/task02.iml" beforeDir="false" afterPath="$PROJECT_DIR$/task02.iml" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DatabaseView">
    <option name="SHOW_INTERMEDIATE" value="true" />
    <option name="GROUP_DATA_SOURCES" value="true" />
    <option name="GROUP_SCHEMA" value="true" />
    <option name="GROUP_CONTENTS" value="false" />
    <option name="SORT_POSITIONED" value="false" />
    <option name="SHOW_EMPTY_GROUPS" value="false" />
    <option name="AUTO_SCROLL_FROM_SOURCE" value="false" />
    <option name="HIDDEN_KINDS">
      <set />
    </option>
    <expand />
    <select />
  </component>
  <component name="DepsLocalSettings">
    <option name="repoId" value="" />
    <option name="repoUrl" value="" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
    <option name="UPDATE_TYPE" value="MERGE" />
  </component>
  <component name="MavenImportPreferences">
    <option name="importingSettings">
      <MavenImportingSettings>
        <option name="jdkForImporter" value="#JAVA_HOME" />
        <option name="vmOptionsForImporter" value="-Xmx768m" />
      </MavenImportingSettings>
    </option>
  </component>
  <component name="ProjectId" id="1UwbjIOpi7nP30yhiXrqHiM1CFW" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="ASKED_ADD_EXTERNAL_FILES" value="true" />
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="project.structure.last.edited" value="Libraries" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.2" />
    <property name="settings.editor.selected.configurable" value="reference.settings.project.maven.importing" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/src/task02" />
      <recent name="$PROJECT_DIR$/src" />
      <recent name="$PROJECT_DIR$/task01" />
    </key>
  </component>
  <component name="ReplState" timestamp="1576686734269">{:repl-history {:ide [], :local [{:command &quot;(def student-tbl (csv/parse-csv (slurp \&quot;student.csv\&quot;)))&quot;, :offset 55, :ns &quot;user&quot;} {:command &quot;(csv/parse-csv (slurp \&quot;student.csv\&quot;))&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(defn table-keys [tbl]\n  (for [f (first tbl) r (rest tbl)] [f r]))&quot;, :offset 66, :ns &quot;user&quot;} {:command &quot;table-keys student-tbl&quot;, :offset 22, :ns &quot;user&quot;} {:command &quot;(defn table-keys [tbl] ([first tbl]))&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(def student-tbl (csv/parse-csv (slurp \&quot;student.csv\&quot;)))\n(def subject-tbl (csv/parse-csv (slurp \&quot;subject.csv\&quot;)))\n(def student-subject-tbl (csv/parse-csv (slurp \&quot;student_subject.csv\&quot;)))&quot;, :offset 183, :ns &quot;user&quot;} {:command &quot;(defn table-keys [tbl] (first tbl))&quot;, :offset 35, :ns &quot;user&quot;} {:command &quot;(table-keys student-tbl)&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  map concat tbl-keys tbl-record)&quot;, :offset 77, :ns &quot;user&quot;} {:command &quot;( (table-keys student-tbl)) &quot;, :offset 1, :ns &quot;user&quot;} {:command &quot; (table-keys student-tbl) &quot;, :offset 24, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  map concat [tbl-keys] [tbl-record])&quot;, :offset 81, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  map list tbl-keys tbl-record)&quot;, :offset 75, :ns &quot;user&quot;} {:command &quot;(key-value-pairs [:id :surname :year :group_id] ([\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1998\&quot;] [\&quot;2\&quot; \&quot;Petrov\&quot; \&quot;1997\&quot;] [\&quot;3\&quot; \&quot;Sidorov\&quot; \&quot;1996\&quot;])) &quot;, :offset 47, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  (map list tbl-keys tbl-record))&quot;, :offset 77, :ns &quot;user&quot;} {:command &quot;(key-value-pairs [:id :surname :year :group_id] '([\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1998\&quot;] [\&quot;2\&quot; \&quot;Petrov\&quot; \&quot;1997\&quot;] [\&quot;3\&quot; \&quot;Sidorov\&quot; \&quot;1996\&quot;])) &quot;, :offset 49, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  (map concat tbl-keys tbl-record))&quot;, :offset 79, :ns &quot;user&quot;} {:command &quot; (rest student-tbl) &quot;, :offset 0, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  (map list tbl-keys (flatten tbl-record)))&quot;, :offset 84, :ns &quot;user&quot;} {:command &quot;(defn key-value-pairs [tbl-keys tbl-record]\n  (flatten(map list tbl-keys (flatten tbl-record))))&quot;, :offset 54, :ns &quot;user&quot;} {:command &quot;(ns csvdb.core-test\n  (:require [clojure.test :refer :all]\n        [csvdb.core :refer :all]))\n\n(deftest table-keys-test\n     (testing\n       (is (= (vec (table-keys student-tbl)))\n             [:id :surname :year :group_id])))&quot;, :offset 226, :ns &quot;user&quot;} {:command &quot;(key-value-pairs (table-keys student-tbl) (rest student-tbl)) &quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(defn order-by* [data column]\n\t(take column data))&quot;, :offset 50, :ns &quot;user&quot;} {:command &quot;(defn limit* [data lim]\n\t(take lim data))&quot;, :offset 41, :ns &quot;user&quot;} {:command &quot;(def student (-&gt;&gt; (data-table student-tbl)\n\t\t\t\t  (map #(str-field-to-int :id %))\n\t\t\t\t  (map #(str-field-to-int :year %))))&quot;, :offset 122, :ns &quot;user&quot;} {:command &quot;(ns csvdb.core\n\t(:require [clojure-csv.core :as csv]))\n\n(defn parse-int [int-str]\n\t(Integer/parseInt int-str))\n\n\n(def student-tbl (csv/parse-csv (slurp \&quot;student.csv\&quot;)))\n(def subject-tbl (csv/parse-csv (slurp \&quot;subject.csv\&quot;)))\n(def student-subject-tbl (csv/parse-csv (slurp \&quot;student_subject.csv\&quot;)))\n\n;; (table-keys student-tbl)\n;; =&gt; [:id :surname :year :group_id]\n;;\n;; Hint: vec, map, keyword, first\n(defn table-keys [tbl] (map\n\t\t\t\t\t\t   keyword (first tbl)))\n\n\n\n;; (key-value-pairs [:id :surname :year :group_id] [\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1996\&quot;])\n;; =&gt; (:id \&quot;1\&quot; :surname \&quot;Ivanov\&quot; :year \&quot;1996\&quot;)\n;;\n;; Hint: flatten, map, list\n(defn key-value-pairs [tbl-keys tbl-record]\n\t(flatten\n\t\t(map\n\t\t\tlist tbl-keys tbl-record))); [tbl-keys])\n\n;; (data-record [:id :surname :year :group_id] [\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1996\&quot;])\n;; =&gt; {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;}\n;;\n;; Hint: apply, hash-map, key-value-pairs\n(defn data-record [tbl-keys tbl-record]\n\t(into {}\n\t\t  (map\n\t\t\t  vector tbl-keys tbl-record)))\n\n\n;; (data-table student-tbl)\n;; =&gt; ({:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;}\n;;     {:surname \&quot;Petrov\&quot;, :year \&quot;1996\&quot;, :id \&quot;2\&quot;}\n;;     {:surname \&quot;Sidorov\&quot;, :year \&quot;1997\&quot;, :id \&quot;3\&quot;})\n;;\n;; Hint: let, map, next, table-keys, data-record\n(defn data-table [tbl]\n\t(let [[keys &amp; vals]  tbl]\n\t\t(map\n\t\t\t(partial\n\t\t\t\tdata-record\n\t\t\t\t(map\n\t\t\t\t\tkeyword keys))\n\t\t\tvals)))\n\n;; (str-field-to-int :id {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;})\n;; =&gt; {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id 1}\n;;\n;; Hint: assoc, Integer/parseInt, get\n(defn str-field-to-int [field rec]\n\t(assoc\n\t\trec field (parse-int\n\t\t\t\t\t  (rec field))))\n\n\n\n(def student (-&gt;&gt; (data-table student-tbl)\n\t\t\t\t  (map #(str-field-to-int :id %))\n\t\t\t\t  (map #(str-field-to-int :year %))))\n\n(def subject (-&gt;&gt; (data-table subject-tbl)\n\t\t\t\t  (map #(str-field-to-int :id %))))\n\n(def student-subject (-&gt;&gt; (data-table student-subject-tbl)\n\t\t\t\t\t\t  (map #(str-field-to-int :subject_id %))\n\t\t\t\t\t\t  (map #(str-field-to-int :student_id %))))\n\n\n;; (where* student (fn [rec] (&gt; (:id rec) 1)))\n;; =&gt; ({:surname \&quot;Petrov\&quot;, :year 1997, :id 2} {:surname \&quot;Sidorov\&quot;, :year 1996, :id 3})\n;;\n;; Hint: if-not, filter\n(defn where* [data condition-func]\n\t(filter condition-func data))\n\n;; (limit* student 1)\n;; =&gt; ({:surname \&quot;Ivanov\&quot;, :year 1998, :id 1})\n;;\n;; Hint: if-not, take\n(defn limit* [data lim]\n\t(take lim data))&quot;, :offset 2316, :ns &quot;user&quot;} {:command &quot;(limit* student 1)&quot;, :offset 18, :ns &quot;csvdb.core&quot;} {:command &quot;(defn order-by* [data column]\n\t(sort-by column data))&quot;, :offset 53, :ns &quot;csvdb.core&quot;} {:command &quot;(order-by* student :year)&quot;, :offset 25, :ns &quot;csvdb.core&quot;} {:command &quot;(where* student-subject #(= :student_id :id))&quot;, :offset 45, :ns &quot;csvdb.core&quot;} {:command &quot;(where* student-subject #(= (student-subject :student_id) (student :id)))&quot;, :offset 73, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t(into {}\n\t\t  (for [el1 data1]\n\t\t\t  (for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2) ) ) )\n\t)&quot;, :offset 156, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2) ) ) )&quot;, :offset 148, :ns &quot;csvdb.core&quot;} {:command &quot;student-subject&quot;, :offset 15, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge (flatten el1) (flatten el2)) ) ) )&quot;, :offset 168, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] (flatten(merge el1 el2)) ) ) )&quot;, :offset 150, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2)) ) ) &quot;, :offset 148, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] el1 el2) ) ) &quot;, :offset 134, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] el2) ) ) &quot;, :offset 127, :ns &quot;csvdb.core&quot;} {:command &quot;(flatten(join* student-subject :student_id student :id))&quot;, :offset 56, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t\n\t\t  (for [el1 data1]\n\t\t\t  (flatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge (el1 el2)))))\n\t\t  )&quot;, :offset 157, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t(into {}\n\t\t  (for [el1 data1]\n\t\t\t  (flatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge (el1 el2)))))\n\t\t  ))&quot;, :offset 167, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t(into {}\n\t\t  (for [el1 data1]\n\t\t\t  (flatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2))))))&quot;, :offset 160, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(flatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2)))))&quot;, :offset 154, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2))))&quot;, :offset 145, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(flatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2)) ) ))&quot;, :offset 156, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\tflatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2)) ) ) &quot;, :offset 154, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(flatten(for [el2 data2 :when(= (el1 column1) (el2 column2))] (merge el1 el2)) ) )) &quot;, :offset 74, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(for [el1 data1]\n\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))] (flatten (merge el1 el2)))))&quot;, :offset 155, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t;(into {}\n\t(flatten(for [el1 data1]\n\t\t\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))]  (merge el1 el2)))))&quot;, :offset 157, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t(into {}\n\t(flatten(for [el1 data1]\n\t\t\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))]  (merge el1 el2))))))&quot;, :offset 157, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t(flatten(for [el1 data1]\n\t\t\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))]  (merge el1 el2)))))&quot;, :offset 143, :ns &quot;csvdb.core&quot;} {:command &quot;(join* student-subject :student_id student :id)&quot;, :offset 47, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t(for [el1 data1]\n\t\t\t\t(for [el2 data2 :when(= (el1 column1) (el2 column2))]  (merge el1 el2))))&quot;, :offset 136, :ns &quot;csvdb.core&quot;} {:command &quot;(ns csvdb.core\n\t(:require [clojure-csv.core :as csv]))\n\n(defn parse-int [int-str]\n\t\t(Integer/parseInt int-str))\n\n\n(def student-tbl (csv/parse-csv (slurp \&quot;student.csv\&quot;)))\n(def subject-tbl (csv/parse-csv (slurp \&quot;subject.csv\&quot;)))\n(def student-subject-tbl (csv/parse-csv (slurp \&quot;student_subject.csv\&quot;)))\n\n;; (table-keys student-tbl)\n;; =&gt; [:id :surname :year :group_id]\n;;\n;; Hint: vec, map, keyword, first\n(defn table-keys [tbl] (map\n\t\t\t\t\t\t\t\t  keyword (first tbl)))\n\n\n\n;; (key-value-pairs [:id :surname :year :group_id] [\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1996\&quot;])\n;; =&gt; (:id \&quot;1\&quot; :surname \&quot;Ivanov\&quot; :year \&quot;1996\&quot;)\n;;\n;; Hint: flatten, map, list\n(defn key-value-pairs [tbl-keys tbl-record]\n\t\t(flatten\n\t\t\t(map\n\t\t\t\tlist tbl-keys tbl-record))); [tbl-keys])\n\n;; (data-record [:id :surname :year :group_id] [\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1996\&quot;])\n;; =&gt; {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;}\n;;\n;; Hint: apply, hash-map, key-value-pairs\n(defn data-record [tbl-keys tbl-record]\n\t\t(into {}\n\t\t\t\t(map\n\t\t\t\t\tvector tbl-keys tbl-record)))\n\n\n;; (data-table student-tbl)\n;; =&gt; ({:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;}\n;;     {:surname \&quot;Petrov\&quot;, :year \&quot;1996\&quot;, :id \&quot;2\&quot;}\n;;     {:surname \&quot;Sidorov\&quot;, :year \&quot;1997\&quot;, :id \&quot;3\&quot;})\n;;\n;; Hint: let, map, next, table-keys, data-record\n(defn data-table [tbl]\n\t\t(let [[keys &amp; vals]  tbl]\n\t\t\t(map\n\t\t\t\t(partial\n\t\t\t\t\tdata-record\n\t\t\t\t\t(map\n\t\t\t\t\t\tkeyword keys))\n\t\t\t\tvals)))\n\n;; (str-field-to-int :id {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;})\n;; =&gt; {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id 1}\n;;\n;; Hint: assoc, Integer/parseInt, get\n(defn str-field-to-int [field rec]\n\t\t(assoc\n\t\t\trec field (parse-int\n\t\t\t\t\t\t\t (rec field))))\n\n\n\n(def student (-&gt;&gt; (data-table student-tbl)\n\t\t\t\t\t\t(map #(str-field-to-int :id %))\n\t\t\t\t\t\t(map #(str-field-to-int :year %))))\n\n(def subject (-&gt;&gt; (data-table subject-tbl)\n\t\t\t\t\t\t(map #(str-field-to-int :id %))))\n\n(def student-subject (-&gt;&gt; (data-table student-subject-tbl)\n\t\t\t\t\t\t\t\t  (map #(str-field-to-int :subject_id %))\n\t\t\t\t\t\t\t\t  (map #(str-field-to-int :student_id %))))\n\n\n;; (where* student (fn [rec] (&gt; (:id rec) 1)))\n;; =&gt; ({:surname \&quot;Petrov\&quot;, :year 1997, :id 2} {:surname \&quot;Sidorov\&quot;, :year 1996, :id 3})\n;;\n;; Hint: if-not, filter\n(defn where* [data condition-func]\n\t\t(filter condition-func data))\n\n;; (limit* student 1)\n;; =&gt; ({:surname \&quot;Ivanov\&quot;, :year 1998, :id 1})\n;;\n;; Hint: if-not, take\n(defn limit* [data lim]\n\t\t(take lim data))\n\n;; (order-by* student :year)\n;; =&gt; ({:surname \&quot;Sidorov\&quot;, :year 1996, :id 3} {:surname \&quot;Petrov\&quot;, :year 1997, :id 2} {:surname \&quot;Ivanov\&quot;, :year 1998, :id 1})\n;; Hint: if-not, sort-by\n(defn order-by* [data column]\n\t\t(sort-by column data))\n\n;; (join* (join* student-subject :student_id student :id) :subject_id subject :id)\n;; =&gt; [{:subject \&quot;Math\&quot;, :subject_id 1, :surname \&quot;Ivanov\&quot;, :year 1998, :student_id 1, :id 1}\n;;     {:subject \&quot;Math\&quot;, :subject_id 1, :surname \&quot;Petrov\&quot;, :year 1997, :student_id 2, :id 2}\n;;     {:subject \&quot;CS\&quot;, :subject_id 2, :surname \&quot;Petrov\&quot;, :year 1997, :student_id 2, :id 2}\n;;     {:subject \&quot;CS\&quot;, :subject_id 2, :surname \&quot;Sidorov\&quot;, :year 1996, :student_id 3, :id 3}]\n;;\n;; Hint: reduce, conj, merge, first, filter, get\n;; Here column1 belongs to data1, column2 belongs to data2.\n;; 1. Start collecting results from empty collection.\n;; 2. Go through each element of data1.\n;; 3. For each element of data1 (lets call it element1) find all elements of data2 (lets call each as element2) where column1 = column2.\n;; 4. Use function 'merge' and merge element1 with each element2.\n;; 5. Collect merged elements.\n(defn join* [data1 column1 data2 column2]\n\t\t(flatten\n\t\t\t(for\n\t\t\t\t[el1 data1]\t(for\n\t\t\t\t\t\t\t\t\t  [el2 data2 :when (=\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (el1 column1) (el2 column2))] (merge\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t el1 el2)))))&quot;, :offset 3676, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t\t(flatten\n\t\t\t(for\n\t\t\t\t[el1 data1]\t(for [el2 data2 :when (= (el1 column1) (el2 column2))] (merge el1 el2)))))&quot;, :offset 151, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t\t(flatten\n\t\t\t(for\n\t\t\t\t[el1 data1]\t(for [el2 data2 :when (= (el1 column1) (el2 column2))] el1))))&quot;, :offset 139, :ns &quot;csvdb.core&quot;} {:command &quot;(defn join* [data1 column1 data2 column2]\n\t\t(flatten\n\t\t\t(for\n\t\t\t\t[el1 data1]\t(for [el2 data2 :when (= (el1 column1) (el2 column2))] (merge el2 el1)))))&quot;, :offset 151, :ns &quot;csvdb.core&quot;} {:command &quot;(join* (join* student-subject :student_id student :id) :subject_id subject :id)&quot;, :offset 79, :ns &quot;csvdb.core&quot;} {:command &quot;(ns csvdb.core\n\t(:require [clojure-csv.core :as csv]))\n\n(defn parse-int [int-str]\n\t\t(Integer/parseInt int-str))\n\n\n(def student-tbl (csv/parse-csv (slurp \&quot;student.csv\&quot;)))\n(def subject-tbl (csv/parse-csv (slurp \&quot;subject.csv\&quot;)))\n(def student-subject-tbl (csv/parse-csv (slurp \&quot;student_subject.csv\&quot;)))\n\n;; (table-keys student-tbl)\n;; =&gt; [:id :surname :year :group_id]\n;;\n;; Hint: vec, map, keyword, first\n(defn table-keys [tbl] (map\n\t\t\t\t\t\t\t\t  keyword (first tbl)))\n\n\n\n;; (key-value-pairs [:id :surname :year :group_id] [\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1996\&quot;])\n;; =&gt; (:id \&quot;1\&quot; :surname \&quot;Ivanov\&quot; :year \&quot;1996\&quot;)\n;;\n;; Hint: flatten, map, list\n(defn key-value-pairs [tbl-keys tbl-record]\n\t\t(flatten\n\t\t\t(map\n\t\t\t\tlist tbl-keys tbl-record))); [tbl-keys])\n\n;; (data-record [:id :surname :year :group_id] [\&quot;1\&quot; \&quot;Ivanov\&quot; \&quot;1996\&quot;])\n;; =&gt; {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;}\n;;\n;; Hint: apply, hash-map, key-value-pairs\n(defn data-record [tbl-keys tbl-record]\n\t\t(into {}\n\t\t\t\t(map\n\t\t\t\t\tvector tbl-keys tbl-record)))\n\n\n;; (data-table student-tbl)\n;; =&gt; ({:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;}\n;;     {:surname \&quot;Petrov\&quot;, :year \&quot;1996\&quot;, :id \&quot;2\&quot;}\n;;     {:surname \&quot;Sidorov\&quot;, :year \&quot;1997\&quot;, :id \&quot;3\&quot;})\n;;\n;; Hint: let, map, next, table-keys, data-record\n(defn data-table [tbl]\n\t\t(let [[keys &amp; vals]  tbl]\n\t\t\t(map\n\t\t\t\t(partial\n\t\t\t\t\tdata-record\n\t\t\t\t\t(map\n\t\t\t\t\t\tkeyword keys))\n\t\t\t\tvals)))\n\n;; (str-field-to-int :id {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id \&quot;1\&quot;})\n;; =&gt; {:surname \&quot;Ivanov\&quot;, :year \&quot;1996\&quot;, :id 1}\n;;\n;; Hint: assoc, Integer/parseInt, get\n(defn str-field-to-int [field rec]\n\t\t(assoc\n\t\t\trec field (parse-int\n\t\t\t\t\t\t\t (rec field))))\n\n\n\n(def student (-&gt;&gt; (data-table student-tbl)\n\t\t\t\t\t\t(map #(str-field-to-int :id %))\n\t\t\t\t\t\t(map #(str-field-to-int :year %))))\n\n(def subject (-&gt;&gt; (data-table subject-tbl)\n\t\t\t\t\t\t(map #(str-field-to-int :id %))))\n\n(def student-subject (-&gt;&gt; (data-table student-subject-tbl)\n\t\t\t\t\t\t\t\t  (map #(str-field-to-int :subject_id %))\n\t\t\t\t\t\t\t\t  (map #(str-field-to-int :student_id %))))\n\n\n;; (where* student (fn [rec] (&gt; (:id rec) 1)))\n;; =&gt; ({:surname \&quot;Petrov\&quot;, :year 1997, :id 2} {:surname \&quot;Sidorov\&quot;, :year 1996, :id 3})\n;;\n;; Hint: if-not, filter\n(defn where* [data condition-func]\n\t\t(filter condition-func data))\n\n;; (limit* student 1)\n;; =&gt; ({:surname \&quot;Ivanov\&quot;, :year 1998, :id 1})\n;;\n;; Hint: if-not, take\n(defn limit* [data lim]\n\t\t(take lim data))\n\n;; (order-by* student :year)\n;; =&gt; ({:surname \&quot;Sidorov\&quot;, :year 1996, :id 3} {:surname \&quot;Petrov\&quot;, :year 1997, :id 2} {:surname \&quot;Ivanov\&quot;, :year 1998, :id 1})\n;; Hint: if-not, sort-by\n(defn order-by* [data column]\n\t\t(sort-by column data))\n\n;; (join* (join* student-subject :student_id student :id) :subject_id subject :id)\n;; =&gt; [{:subject \&quot;Math\&quot;, :subject_id 1, :surname \&quot;Ivanov\&quot;, :year 1998, :student_id 1, :id 1}\n;;     {:subject \&quot;Math\&quot;, :subject_id 1, :surname \&quot;Petrov\&quot;, :year 1997, :student_id 2, :id 2}\n;;     {:subject \&quot;CS\&quot;, :subject_id 2, :surname \&quot;Petrov\&quot;, :year 1997, :student_id 2, :id 2}\n;;     {:subject \&quot;CS\&quot;, :subject_id 2, :surname \&quot;Sidorov\&quot;, :year 1996, :student_id 3, :id 3}]\n;;\n;; Hint: reduce, conj, merge, first, filter, get\n;; Here column1 belongs to data1, column2 belongs to data2.\n;; 1. Start collecting results from empty collection.\n;; 2. Go through each element of data1.\n;; 3. For each element of data1 (lets call it element1) find all elements of data2 (lets call each as element2) where column1 = column2.\n;; 4. Use function 'merge' and merge element1 with each element2.\n;; 5. Collect merged elements.\n(defn join* [data1 column1 data2 column2]\n\t\t(flatten\n\t\t\t(for\n\t\t\t\t[el1 data1]\t(for [el2 data2 :when (= (el1 column1) (el2 column2))] (merge el2 el1)))))\n\n; (perform-joins student-subject [[:student_id student :id] [:subject_id subject :id]])\n; =&gt; [{:subject \&quot;Math\&quot;, :subject_id 1, :surname \&quot;Ivanov\&quot;, :year 1998, :student_id 1, :id 1}\n; \t\t{:subject \&quot;Math\&quot;, :subject_id 1, :surname \&quot;Petrov\&quot;, :year 1997, :student_id 2, :id 2}\n; \t\t{:subject \&quot;CS\&quot;, :subject_id 2, :surname \&quot;Petrov\&quot;, :year 1997, :student_id 2, :id 2}\n; \t\t{:subject \&quot;CS\&quot;, :subject_id 2, :surname \&quot;Sidorov\&quot;, :year 1996, :student_id 3, :id 3}]\n;\n; Hint: loop-recur, let, first, next, join*\n(defn perform-joins [data joins*]\n\t\t(loop [data1 data\n\t\t\t\t joins joins*]\n\t\t\t(if (empty? joins)\n\t\t\t\tdata1\n\t\t\t\t(let [[col1 data2 col2] (first joins)]\n\t\t\t\t\t(recur (join* data1 col1 data2 col2)\n\t\t\t\t\t\t\t (next joins))))))\n\n(defn select [data &amp; {:keys [where limit order-by joins]}]\n\t\t(-&gt; data\n\t\t\t (perform-joins joins)\n\t\t\t (where* where)\n\t\t\t (order-by* order-by)\n\t\t\t (limit* limit)))&quot;, :offset 4493, :ns &quot;user&quot;} {:command &quot;(select student)&quot;, :offset 16, :ns &quot;csvdb.core&quot;}], :remote []}}</component>
  <component name="RunManager" selected="Clojure REPL.REPL">
    <configuration name="REPL" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="task02" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="dev" />
      <setting name="aliases" value="" />
      <shortenClasspath name="ARGS_FILE" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="Unnamed" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" singleton="true" nameIsGenerated="true">
      <module name="csvdb" />
      <setting name="path" value="$PROJECT_DIR$/test/csvdb/core_test.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure Application.Unnamed" />
      <item itemvalue="Clojure REPL.REPL" />
    </list>
  </component>
  <component name="ServiceViewManager">
    <option name="viewStates">
      <list>
        <serviceView>
          <treeState>
            <expand />
            <select />
          </treeState>
        </serviceView>
      </list>
    </option>
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
    <MESSAGE value="i" />
    <option name="LAST_COMMIT_MESSAGE" value="i" />
  </component>
  <component name="WindowStateProjectService">
    <state x="1706" y="553" key="#Clojure" timestamp="1576527631173">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1706" y="553" key="#Clojure/0.23.3200.1731@0.23.3200.1731" timestamp="1576527631173" />
    <state x="1765" y="553" key="#Project_Structure" timestamp="1576677714186">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1765" y="553" key="#Project_Structure/0.23.3200.1731@0.23.3200.1731" timestamp="1576677714186" />
    <state x="1476" y="727" width="1349" height="676" key="#com.intellij.execution.impl.EditConfigurationsDialog" timestamp="1576677805431">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1476" y="727" width="1349" height="676" key="#com.intellij.execution.impl.EditConfigurationsDialog/0.23.3200.1731@0.23.3200.1731" timestamp="1576677805431" />
    <state x="2140" y="784" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1576270917105">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="2140" y="784" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.23.3200.1731@0.23.3200.1731" timestamp="1576270917105" />
    <state x="1757" y="550" key="#com.intellij.openapi.projectRoots.ui.ProjectJdksEditor" timestamp="1576270914047">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1757" y="550" key="#com.intellij.openapi.projectRoots.ui.ProjectJdksEditor/0.23.3200.1731@0.23.3200.1731" timestamp="1576270914047" />
    <state x="1657" y="623" key="#com.intellij.openapi.updateSettings.impl.PluginUpdateInfoDialog" timestamp="1576581851295">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1657" y="623" key="#com.intellij.openapi.updateSettings.impl.PluginUpdateInfoDialog/0.23.3200.1731@0.23.3200.1731" timestamp="1576581851295" />
    <state x="1811" y="490" key="CommitChangelistDialog2" timestamp="1576528502988">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1811" y="490" key="CommitChangelistDialog2/0.23.3200.1731@0.23.3200.1731" timestamp="1576528502988" />
    <state x="640" y="185" key="DiffContextDialog" timestamp="1576527818985">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="640" y="185" key="DiffContextDialog/0.23.3200.1731@0.23.3200.1731" timestamp="1576527818985" />
    <state width="1209" height="626" key="GridCell.Tab.0.bottom" timestamp="1576584998115">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.0.bottom/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998115" />
    <state width="1209" height="626" key="GridCell.Tab.0.center" timestamp="1576584998114">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.0.center/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998114" />
    <state width="1209" height="626" key="GridCell.Tab.0.left" timestamp="1576584998113">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.0.left/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998113" />
    <state width="1209" height="626" key="GridCell.Tab.0.right" timestamp="1576584998114">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.0.right/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998114" />
    <state width="1209" height="626" key="GridCell.Tab.1.bottom" timestamp="1576584998117">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.1.bottom/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998117" />
    <state width="1209" height="626" key="GridCell.Tab.1.center" timestamp="1576584998116">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.1.center/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998116" />
    <state width="1209" height="626" key="GridCell.Tab.1.left" timestamp="1576584998115">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.1.left/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998115" />
    <state width="1209" height="626" key="GridCell.Tab.1.right" timestamp="1576584998117">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state width="1209" height="626" key="GridCell.Tab.1.right/0.23.3200.1731@0.23.3200.1731" timestamp="1576584998117" />
    <state x="1771" y="342" key="SettingsEditor" timestamp="1576677405090">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1771" y="342" key="SettingsEditor/0.23.3200.1731@0.23.3200.1731" timestamp="1576677405090" />
    <state x="1777" y="628" key="Vcs.Push.Dialog.v2" timestamp="1576528510303">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1777" y="628" key="Vcs.Push.Dialog.v2/0.23.3200.1731@0.23.3200.1731" timestamp="1576528510303" />
    <state x="1102" y="325" width="1764" height="1530" key="com.intellij.history.integration.ui.views.FileHistoryDialog" timestamp="1576685738089">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1102" y="325" width="1764" height="1530" key="com.intellij.history.integration.ui.views.FileHistoryDialog/0.23.3200.1731@0.23.3200.1731" timestamp="1576685738089" />
    <state x="1575" y="575" key="com.intellij.ide.util.TipDialog" timestamp="1576691158513">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1575" y="575" key="com.intellij.ide.util.TipDialog/0.23.3200.1731@0.23.3200.1731" timestamp="1576691158513" />
    <state x="1895" y="812" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2" timestamp="1576580970256">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1895" y="812" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.23.3200.1731@0.23.3200.1731" timestamp="1576580970256" />
    <state x="1613" y="614" key="new project wizard" timestamp="1576671427925">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1613" y="614" key="new project wizard/0.23.3200.1731@0.23.3200.1731" timestamp="1576671427925" />
    <state x="1851" y="426" width="764" height="676" key="search.everywhere.popup" timestamp="1576676685679">
      <screen x="0" y="23" width="3200" height="1731" />
    </state>
    <state x="1851" y="426" width="764" height="676" key="search.everywhere.popup/0.23.3200.1731@0.23.3200.1731" timestamp="1576676685679" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/task01/src/csvdb/core.clj</url>
          <line>39</line>
          <option name="timeStamp" value="1" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>jar://$USER_HOME$/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj</url>
          <line>1683</line>
          <option name="timeStamp" value="8" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/task01/test/csvdb/core_test.clj</url>
          <line>45</line>
          <option name="timeStamp" value="9" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/task01/test/csvdb/core_test.clj</url>
          <line>46</line>
          <option name="timeStamp" value="10" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/task01/test/csvdb/core_test.clj</url>
          <line>47</line>
          <option name="timeStamp" value="12" />
        </line-breakpoint>
      </breakpoints>
    </breakpoint-manager>
  </component>
</project>